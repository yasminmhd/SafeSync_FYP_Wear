<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/fyp/safesyncwatch/presentation/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/fyp/safesyncwatch/presentation/MainActivity.kt" />
              <option name="originalContent" value="package com.fyp.safesyncwatch.presentation&#10;&#10;import android.Manifest&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.pm.PackageManager&#10;import android.hardware.Sensor&#10;import android.hardware.SensorEvent&#10;import android.hardware.SensorEventListener&#10;import android.hardware.SensorManager&#10;import android.os.Bundle&#10;import android.os.Handler&#10;import android.os.Looper&#10;import android.util.Log&#10;import android.widget.Toast&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.compose.animation.core.FastOutSlowInEasing&#10;import androidx.compose.animation.core.RepeatMode&#10;import androidx.compose.animation.core.animateFloat&#10;import androidx.compose.animation.core.infiniteRepeatable&#10;import androidx.compose.animation.core.rememberInfiniteTransition&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.DisposableEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateListOf&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.Path&#10;import androidx.compose.ui.graphics.drawscope.Stroke&#10;import androidx.compose.ui.graphics.drawscope.drawIntoCanvas&#10;import androidx.compose.ui.graphics.nativeCanvas&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.platform.LocalLifecycleOwner&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.viewinterop.AndroidView&#10;import androidx.core.content.ContextCompat&#10;import androidx.lifecycle.Lifecycle&#10;import androidx.lifecycle.LifecycleEventObserver&#10;import androidx.wear.compose.material.MaterialTheme&#10;import androidx.wear.compose.material.Text&#10;import com.fyp.safesyncwatch.theme.PulseHeartView&#10;import com.fyp.safesyncwatch.theme.SafeSyncWatchTheme&#10;import com.google.android.gms.wearable.PutDataMapRequest&#10;import com.google.android.gms.wearable.Wearable&#10;import java.util.concurrent.TimeUnit&#10;import java.time.*&#10;import androidx.compose.material3.Surface&#10;import android.content.BroadcastReceiver&#10;import android.content.IntentFilter&#10;import android.annotation.SuppressLint&#10;&#10;fun startOfTodayMillis(): Long {&#10;    val zone = ZoneId.systemDefault()&#10;    return LocalDate.now(zone).atStartOfDay(zone).toInstant().toEpochMilli()&#10;}&#10;&#10;data class HeartRateEntry(&#10;    val timestamp: Long,&#10;    val bpm: Int&#10;)&#10;class MainActivity : ComponentActivity(), SensorEventListener {&#10;    companion object {&#10;        const val ACTION_HR_UPDATED = &quot;com.fyp.safesyncwatch.HEART_RATE_UPDATED&quot;&#10;    }&#10;&#10;    private val hrUpdateReceiver = object : BroadcastReceiver() {&#10;        override fun onReceive(context: Context, intent: Intent) {&#10;            val bpm = intent.getIntExtra(&quot;bpm&quot;, -1)&#10;            val ts = intent.getLongExtra(&quot;timestamp&quot;, System.currentTimeMillis())&#10;            if (bpm &gt; 0) {&#10;                // Avoid duplicate entries with same timestamp&#10;                if (heartRateHistory.isEmpty() || heartRateHistory.last().timestamp != ts) {&#10;                    heartRateHistory.add(HeartRateEntry(ts, bpm))&#10;                    // keep UI state in sync&#10;                    heartRateBpm = bpm&#10;                    pruneOldHeartRateHistory(startOfTodayMillis())&#10;                    saveHeartRateHistory()&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private lateinit var sensorManager: SensorManager&#10;    private var heartRateSensor: Sensor? = null&#10;    private var heartRateBpm by mutableStateOf(0)&#10;    private var sensorPermissionGranted by mutableStateOf(false)&#10;    private val TAG = &quot;HeartRate&quot;&#10;    private val heartRateHistory = mutableStateListOf&lt;HeartRateEntry&gt;()&#10;    private val handler = Handler(Looper.getMainLooper())&#10;    private var showDetachedDialog by mutableStateOf(false)&#10;    private val bpmTimeoutMs = 30_000L // 30 seconds&#10;    private var lastValidBpmTime by mutableStateOf(0L) // Keep track of the last valid BPM time&#10;    private var emergencyActivated by mutableStateOf(false)&#10;    private var emergencyDismissedAt by mutableStateOf(0L) // avoid immediate re-trigger&#10;&#10;    private val requestBackgroundPermissionLauncher =&#10;        registerForActivityResult(ActivityResultContracts.RequestPermission()) { isGranted: Boolean -&gt;&#10;            if (isGranted) {&#10;                android.util.Log.d(TAG, &quot;BODY_SENSORS_BACKGROUND granted.&quot;)&#10;                startHrService()&#10;            } else {&#10;                android.util.Log.e(TAG, &quot;BODY_SENSORS_BACKGROUND denied.&quot;)&#10;                // still attempt to start the service on older devices; for API 34+ it's required to have bg permission&#10;                if (android.os.Build.VERSION.SDK_INT &lt; 34) startHrService()&#10;            }&#10;        }&#10;&#10;    private val requestPermissionLauncher =&#10;        registerForActivityResult(ActivityResultContracts.RequestPermission()) { isGranted: Boolean -&gt;&#10;            if (isGranted) {&#10;                Log.d(TAG, &quot;BODY_SENSORS permission GRANTED by user.&quot;)&#10;                sensorPermissionGranted = true&#10;                initializeAndRegisterSensor()&#10;&#10;                // Request background sensors permission explicitly on Android 34+&#10;                if (android.os.Build.VERSION.SDK_INT &gt;= 34) {&#10;                    // launch the background permission flow&#10;                    requestBackgroundPermissionLauncher.launch(Manifest.permission.BODY_SENSORS_BACKGROUND)&#10;                } else {&#10;                    startHrService()&#10;                }&#10;            } else {&#10;                Log.e(TAG, &quot;BODY_SENSORS permission DENIED by user.&quot;)&#10;                sensorPermissionGranted = false&#10;                heartRateBpm = -1&#10;            }&#10;        }&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        Log.d(TAG, &quot;onCreate called&quot;)&#10;        sensorManager = getSystemService(Context.SENSOR_SERVICE) as SensorManager&#10;        loadHeartRateHistory()&#10;        setContent {&#10;            SafeSyncWatchTheme {&#10;                if (!sensorPermissionGranted) { RequestHeartRatePermission() }&#10;&#10;                WearRoot(&#10;                    heartRateList = heartRateHistory.toList(),&#10;                    latestBpm = heartRateBpm,&#10;                    permissionGranted = sensorPermissionGranted,&#10;                    emergencyRequested = emergencyActivated,&#10;                    onEmergencyHandled = {&#10;                        // Clear the activation and mark dismissal time so sensor won't re-trigger immediately&#10;                        emergencyActivated = false&#10;                        emergencyDismissedAt = System.currentTimeMillis()&#10;                    }&#10;                )&#10;&#10;                SensorLifecycleEffect()&#10;            }&#10;        }&#10;    }&#10;&#10;    @Composable&#10;    private fun RequestHeartRatePermission() {&#10;        DisposableEffect(Unit) {&#10;            when (ContextCompat.checkSelfPermission(this@MainActivity, Manifest.permission.BODY_SENSORS)) {&#10;                PackageManager.PERMISSION_GRANTED -&gt; {&#10;                    Log.d(TAG, &quot;BODY_SENSORS permission already granted (checked in Composable).&quot;)&#10;                    sensorPermissionGranted = true&#10;                    if (android.os.Build.VERSION.SDK_INT &gt;= 34) {&#10;                        startHrService()&#10;                    } else {&#10;                        startHrService()&#10;                    }&#10;                }&#10;                else -&gt; {&#10;                    Log.d(TAG, &quot;Requesting BODY_SENSORS permission from Composable.&quot;)&#10;                    requestPermissionLauncher.launch(Manifest.permission.BODY_SENSORS)&#10;                }&#10;            }&#10;            onDispose { }&#10;        }&#10;    }&#10;&#10;    private fun initializeAndRegisterSensor() {&#10;        if (!sensorPermissionGranted) {&#10;            Log.w(TAG, &quot;initializeAndRegisterSensor: Permission not granted. Aborting.&quot;)&#10;            heartRateBpm = -1 // Indicates permission issue&#10;            return&#10;        }&#10;        if (heartRateSensor == null) {&#10;            heartRateSensor = sensorManager.getDefaultSensor(Sensor.TYPE_HEART_RATE)&#10;        }&#10;        if (heartRateSensor == null) {&#10;            Log.e(TAG, &quot;Heart rate sensor NOT AVAILABLE on this device.&quot;)&#10;            heartRateBpm = -2 // Indicates sensor N/A&#10;        } else {&#10;            Log.d(TAG, &quot;Heart rate sensor found: ${heartRateSensor?.name}. Registering listener.&quot;)&#10;            val registered = sensorManager.registerListener(this, heartRateSensor, SensorManager.SENSOR_DELAY_NORMAL)&#10;            if (registered) {&#10;                Log.d(TAG, &quot;Heart rate listener registered successfully.&quot;)&#10;                // Start the timeout check immediately after registering&#10;                handler.removeCallbacks(bpmTimeoutRunnable)&#10;                handler.postDelayed(bpmTimeoutRunnable, bpmTimeoutMs)&#10;                lastValidBpmTime = System.currentTimeMillis() // Initialize time&#10;            } else {&#10;                Log.e(TAG, &quot;Failed to register heart rate listener.&quot;)&#10;                heartRateBpm = -2 // Treat as sensor N/A if registration fails&#10;            }&#10;        }&#10;    }&#10;&#10;    private val bpmTimeoutRunnable = Runnable {&#10;        // Only trigger if no new BPM has come in since the timeout was scheduled&#10;        if (System.currentTimeMillis() - lastValidBpmTime &gt;= bpmTimeoutMs) {&#10;            heartRateBpm = 0&#10;            Toast.makeText(&#10;                this,&#10;                &quot;No heart rate detected. Please ensure the watch is properly worn.&quot;,&#10;                Toast.LENGTH_LONG&#10;            ).show()&#10;            Log.d(TAG, &quot;BPM Timeout! Setting BPM to 0 and showing Toast.&quot;)&#10;        }&#10;    }&#10;&#10;    private fun unregisterSensorListener() {&#10;        Log.d(TAG, &quot;Unregistering heart rate listener.&quot;)&#10;        sensorManager.unregisterListener(this)&#10;    }&#10;&#10;    @Composable&#10;    private fun SensorLifecycleEffect() {&#10;        val lifecycleOwner = LocalLifecycleOwner.current&#10;        DisposableEffect(lifecycleOwner, sensorPermissionGranted) {&#10;            val observer = LifecycleEventObserver { _, event -&gt;&#10;                when (event) {&#10;                    Lifecycle.Event.ON_RESUME -&gt; {&#10;                        Log.d(TAG, &quot;SensorLifecycleEffect: ON_RESUME&quot;)&#10;                        if (sensorPermissionGranted) {&#10;                        }&#10;                    }&#10;                    Lifecycle.Event.ON_PAUSE -&gt; {&#10;                        Log.d(TAG, &quot;SensorLifecycleEffect: ON_PAUSE&quot;)&#10;                    }&#10;                    else -&gt; { /* Do nothing */ }&#10;                }&#10;            }&#10;            lifecycleOwner.lifecycle.addObserver(observer)&#10;            onDispose {&#10;                Log.d(TAG, &quot;SensorLifecycleEffect onDispose&quot;)&#10;                lifecycleOwner.lifecycle.removeObserver(observer)&#10;            }&#10;        }&#10;    }&#10;    override fun onSensorChanged(event: SensorEvent?) {&#10;        if (event?.sensor?.type == Sensor.TYPE_HEART_RATE) {&#10;            val bpm = event.values[0].toInt()&#10;            val currentTime = System.currentTimeMillis()&#10;            if (bpm &gt; 0) {&#10;                heartRateBpm = bpm&#10;                if (bpm &gt; 140 &amp;&amp; !emergencyActivated &amp;&amp; currentTime - emergencyDismissedAt &gt; TimeUnit.SECONDS.toMillis(30)) {&#10;                    emergencyActivated = true&#10;                }&#10;                if (heartRateHistory.isEmpty() || heartRateHistory.last().bpm != bpm) {&#10;                    heartRateHistory.add(HeartRateEntry(currentTime, bpm))&#10;                    pruneOldHeartRateHistory(System.currentTimeMillis() - TimeUnit.HOURS.toMillis(48))&#10;                    saveHeartRateHistory()&#10;                }&#10;                sendHeartRateToPhone(bpm)&#10;                lastValidBpmTime = currentTime&#10;                handler.removeCallbacks(bpmTimeoutRunnable)&#10;                handler.postDelayed(bpmTimeoutRunnable, bpmTimeoutMs)&#10;            } else if (bpm == 0 &amp;&amp; heartRateBpm &gt; 0) {&#10;                handler.removeCallbacks(bpmTimeoutRunnable)&#10;                handler.postDelayed(bpmTimeoutRunnable, bpmTimeoutMs)&#10;            }&#10;        }&#10;    }&#10;&#10;    @SuppressLint(&quot;UnspecifiedRegisterReceiverFlag&quot;)&#10;    override fun onResume() {&#10;        super.onResume()&#10;        pruneOldHeartRateHistory(startOfTodayMillis())&#10;        if (sensorPermissionGranted) initializeAndRegisterSensor()&#10;        // Register receiver to update graph in real-time&#10;        val filter = IntentFilter(ACTION_HR_UPDATED)&#10;        if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.TIRAMISU) {&#10;            // mark as not exported for unprotected local broadcasts&#10;            registerReceiver(hrUpdateReceiver, filter, Context.RECEIVER_NOT_EXPORTED)&#10;        } else {&#10;            // older devices: lint suppressed above because we intentionally use the older overload&#10;            registerReceiver(hrUpdateReceiver, filter)&#10;        }&#10;&#10;        // Load history saved by the background service while activity was paused / screen-off&#10;        try {&#10;            loadHeartRateHistory()&#10;            // Ensure we only show today's data on resume&#10;            pruneOldHeartRateHistory(startOfTodayMillis())&#10;            if (heartRateHistory.isNotEmpty()) {&#10;                heartRateBpm = heartRateHistory.last().bpm&#10;            }&#10;            Log.d(TAG, &quot;onResume: Loaded ${heartRateHistory.size} history entries from prefs&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;onResume: failed to load heart rate history&quot;, e)&#10;        }&#10;    }&#10;&#10;    override fun onPause() {&#10;        super.onPause()&#10;        Log.d(TAG, &quot;Lifecycle.Event.ON_PAUSE from Activity&quot;)&#10;        unregisterSensorListener()&#10;        handler.removeCallbacks(bpmTimeoutRunnable)&#10;        // Unregister receiver&#10;        try { unregisterReceiver(hrUpdateReceiver) } catch (_: Exception) { }&#10;    }&#10;&#10;    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {&#10;        val accuracyStatus = when (accuracy) {&#10;            SensorManager.SENSOR_STATUS_ACCURACY_HIGH -&gt; &quot;HIGH&quot;&#10;            SensorManager.SENSOR_STATUS_ACCURACY_MEDIUM -&gt; &quot;MEDIUM&quot;&#10;            SensorManager.SENSOR_STATUS_ACCURACY_LOW -&gt; &quot;LOW&quot;&#10;            SensorManager.SENSOR_STATUS_UNRELIABLE -&gt; &quot;UNRELIABLE&quot;&#10;            else -&gt; &quot;UNKNOWN ($accuracy)&quot;&#10;        }&#10;        Log.d(TAG, &quot;onAccuracyChanged: ${sensor?.name}, accuracy: $accuracyStatus&quot;)&#10;    }&#10;&#10;    private fun sendHeartRateToPhone(bpm: Int) {&#10;        Log.e(&quot;WEAR_SEND_DEBUG&quot;, &quot;!!!! Attempting to SEND BPM ($bpm) to phone. Timestamp: ${System.currentTimeMillis()} !!!!&quot;)&#10;        if (!isFinishing &amp;&amp; !isDestroyed) {&#10;            try {&#10;                val dataClient = Wearable.getDataClient(this)&#10;                val request = PutDataMapRequest.create(&quot;/heartRate&quot;).apply {&#10;                    dataMap.putInt(&quot;bpm&quot;, bpm)&#10;                    dataMap.putLong(&quot;timestamp&quot;, System.currentTimeMillis())&#10;                }.asPutDataRequest().setUrgent()&#10;&#10;                dataClient.putDataItem(request)&#10;                    .addOnSuccessListener { Log.d(&quot;WEAR_SEND_DEBUG&quot;, &quot;SUCCESS: Heart rate data ($bpm BPM) sent.&quot;) }&#10;                    .addOnFailureListener { e -&gt; Log.e(&quot;WEAR_SEND_DEBUG&quot;, &quot;FAILURE: Failed to send heart rate data.&quot;, e) }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;WEAR_SEND_DEBUG&quot;, &quot;EXCEPTION while sending heart rate data&quot;, e)&#10;            }&#10;        } else {&#10;            Log.w(&quot;WEAR_SEND_DEBUG&quot;, &quot;Activity is finishing/destroyed. CANNOT SEND BPM: $bpm&quot;)&#10;        }&#10;    }&#10;&#10;    private fun saveHeartRateHistory() {&#10;        val prefs = getSharedPreferences(&quot;heart_rate_prefs&quot;, Context.MODE_PRIVATE)&#10;        val historyString = heartRateHistory.joinToString(&quot;;&quot;) { &quot;${it.timestamp},${it.bpm}&quot; }&#10;        prefs.edit().putString(&quot;history_v2&quot;, historyString).apply() // Use a new key for the new format&#10;        Log.d(TAG, &quot;Saved history: $historyString&quot;)&#10;    }&#10;&#10;    private fun loadHeartRateHistory() {&#10;        val prefs = getSharedPreferences(&quot;heart_rate_prefs&quot;, Context.MODE_PRIVATE)&#10;        val historyString = prefs.getString(&quot;history_v2&quot;, &quot;&quot;) ?: &quot;&quot;&#10;        heartRateHistory.clear()&#10;        if (historyString.isNotEmpty()) {&#10;            try {&#10;                val entries = historyString.split(&quot;;&quot;).mapNotNull { raw -&gt;&#10;                    val parts = raw.trim().split(&quot;,&quot;)&#10;                    if (parts.size != 2) return@mapNotNull null&#10;                    val ts = parts[0].trim().toLongOrNull() ?: return@mapNotNull null&#10;                    val bpm = parts[1].trim().toIntOrNull() ?: return@mapNotNull null&#10;                    HeartRateEntry(ts, bpm)&#10;                }&#10;                heartRateHistory.addAll(entries)&#10;                // Prune old data on load as well (keep last 48 hours as elsewhere)&#10;                pruneOldHeartRateHistory(System.currentTimeMillis() - TimeUnit.HOURS.toMillis(48))&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error loading heart rate history&quot;, e)&#10;            }&#10;        }&#10;        Log.d(TAG, &quot;Loaded history items: ${heartRateHistory.size}&quot;)&#10;    }&#10;&#10;    //remove data older than a certain point&#10;    private fun pruneOldHeartRateHistory(thresholdTimestamp: Long) {&#10;        val removed = heartRateHistory.removeAll { it.timestamp &lt; thresholdTimestamp }&#10;        if (removed) Log.d(TAG, &quot;Pruned old heart rate entries. Kept: ${heartRateHistory.size}&quot;)&#10;    }&#10;&#10;    private fun startHrService() {&#10;        val i = Intent(this, com.fyp.safesyncwatch.service.HeartRateService::class.java)&#10;        if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.O) {&#10;            startForegroundService(i)&#10;        } else {&#10;            startService(i)&#10;        }&#10;    }&#10;&#10;    private fun stopHrService() {&#10;        val i = Intent(this, com.fyp.safesyncwatch.service.HeartRateService::class.java)&#10;        stopService(i)&#10;    }&#10;&#10;}&#10;data class BinnedPoint(&#10;    val tStart: Long,&#10;    val tCenter: Long,&#10;    val min: Int,&#10;    val median: Int,&#10;    val max: Int,&#10;    val count: Int&#10;)&#10;&#10;fun binHeartRate(&#10;    data: List&lt;HeartRateEntry&gt;,&#10;    windowStartMs: Long,&#10;    windowEndMs: Long,&#10;    binSizeMs: Long&#10;): List&lt;BinnedPoint&gt; {&#10;    if (windowEndMs &lt;= windowStartMs) return emptyList()&#10;&#10;    //Snap bin grid to the window start so x axis line up&#10;    val bStart = windowStartMs&#10;&#10;    val buckets = mutableMapOf&lt;Long, MutableList&lt;Int&gt;&gt;()&#10;    data.forEach { e -&gt;&#10;        if (e.timestamp in windowStartMs..windowEndMs) {&#10;            //Bin key measured from windowStartMs (no modulo shift)&#10;            val offset = e.timestamp - bStart&#10;            val key = bStart + (offset / binSizeMs) * binSizeMs&#10;            buckets.getOrPut(key) { mutableListOf() }.add(e.bpm)&#10;        }&#10;    }&#10;&#10;    val out = mutableListOf&lt;BinnedPoint&gt;()&#10;    var cursor = bStart&#10;    while (cursor &lt; windowEndMs) {&#10;        val list = buckets[cursor]&#10;        if (!list.isNullOrEmpty()) {&#10;            val sorted = list.sorted()&#10;            val sz = sorted.size&#10;            val med = if (sz % 2 == 1) sorted[sz / 2] else ((sorted[sz / 2 - 1] + sorted[sz / 2]) / 2)&#10;            out.add(&#10;                BinnedPoint(&#10;                    tStart = cursor,&#10;                    tCenter = cursor + binSizeMs / 2,&#10;                    min = sorted.first(),&#10;                    median = med,&#10;                    max = sorted.last(),&#10;                    count = sz&#10;                )&#10;            )&#10;        }&#10;        cursor += binSizeMs&#10;    }&#10;    return out&#10;}&#10;&#10;fun ema(values: List&lt;Float&gt;, alpha: Float = 0.3f): List&lt;Float&gt; {&#10;    if (values.isEmpty()) return values&#10;    val out = MutableList(values.size) { 0f }&#10;    out[0] = values[0]&#10;    for (i in 1 until values.size) {&#10;        out[i] = alpha * values[i] + (1 - alpha) * out[i - 1]&#10;    }&#10;    return out&#10;}&#10;&#10;@Composable&#10;fun HeartbeatScreen(bpm: Int, permissionGranted: Boolean) {&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(Color.White),&#10;        verticalArrangement = Arrangement.Center,&#10;        horizontalAlignment = Alignment.CenterHorizontally&#10;    ) {&#10;        Spacer(Modifier.height(15.dp))&#10;&#10;        PulseHeartViewCompose()&#10;&#10;        Spacer(Modifier.height(16.dp))&#10;&#10;        val displayText = when {&#10;            !permissionGranted &amp;&amp; bpm == -1 -&gt; &quot;Permission Denied&quot;&#10;            bpm == -2 -&gt; &quot;Sensor N/A&quot;&#10;            bpm == 0 &amp;&amp; permissionGranted -&gt; &quot;... BpM&quot;&#10;            bpm == 0 &amp;&amp; !permissionGranted -&gt; &quot;Requesting Permission...&quot;&#10;            bpm &gt; 0 &amp;&amp; permissionGranted -&gt; &quot;$bpm BpM&quot;&#10;            else -&gt; &quot;-- BpM&quot;&#10;        }&#10;&#10;        Text(&#10;            text = displayText,&#10;            style = MaterialTheme.typography.title1,&#10;            color = when {&#10;                bpm &gt; 140 &amp;&amp; permissionGranted -&gt; Color(0xFFB00020)&#10;                bpm &gt; 0 &amp;&amp; permissionGranted -&gt; Color.Black&#10;                else -&gt; Color.LightGray&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun HeartRateChartScreen(heartRateList: List&lt;HeartRateEntry&gt;) {&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(Color.White)&#10;            .verticalScroll(rememberScrollState()),&#10;        horizontalAlignment = Alignment.CenterHorizontally&#10;    ) {&#10;        HeartRateTimeChart(heartRateList)&#10;    }&#10;}&#10;&#10;@Composable&#10;fun PulseHeartViewCompose() {&#10;    AndroidView(&#10;        factory = { context -&gt; PulseHeartView(context) },&#10;        modifier = Modifier.size(72.dp)&#10;    )&#10;}&#10;&#10;@Composable&#10;fun HeartRateTimeChart(heartRateData: List&lt;HeartRateEntry&gt;) {&#10;    val chartHeightDp = 180.dp&#10;    val chartWidthDp = LocalConfiguration.current.screenWidthDp.dp - 32.dp&#10;&#10;    val now = System.currentTimeMillis()&#10;    val windowEnd = now&#10;    val windowStart = now - TimeUnit.HOURS.toMillis(1) // last hour&#10;    val durationMs = (windowEnd - windowStart).coerceAtLeast(1L)&#10;&#10;    val points = remember(heartRateData, now) {&#10;        heartRateData&#10;            .filter { it.timestamp in windowStart..windowEnd }&#10;            .sortedBy { it.timestamp }&#10;    }&#10;&#10;    if (points.isEmpty()) {&#10;        Box(&#10;            modifier = Modifier&#10;                .height(chartHeightDp)&#10;                .width(chartWidthDp)&#10;                .padding(8.dp)&#10;                .background(Color.DarkGray.copy(alpha = 0.1f)),&#10;            contentAlignment = Alignment.Center&#10;        ) { Text(&quot;No data in last hour&quot;, color = Color.LightGray) }&#10;        return&#10;    }&#10;&#10;    val bpmSeries = remember(points) { points.map { it.bpm.toFloat() } }&#10;    val smoothed = remember(bpmSeries) { ema(bpmSeries, alpha = 0.25f) }&#10;&#10;    // Determine visual bounds with some breathing room&#10;    val maxBpm = maxOf((points.maxOf { it.bpm }), 40)&#10;    val minBpm = minOf((points.minOf { it.bpm }), maxBpm - 20).coerceAtLeast(30)&#10;    val bpmRange = (maxBpm - minBpm).coerceAtLeast(1).toFloat()&#10;&#10;    val maxGapMs = TimeUnit.MINUTES.toMillis(2) // split the line if gap &gt; 2 minutes&#10;&#10;    Box(&#10;        modifier = Modifier&#10;            .height(chartHeightDp)&#10;            .width(chartWidthDp)&#10;            .padding(vertical = 8.dp)&#10;    ) {&#10;        Canvas(modifier = Modifier.matchParentSize()) {&#10;            val bottomPad = 36.dp.toPx()&#10;            val leftPad = 35.dp.toPx()&#10;            val topPad = 50.dp.toPx()&#10;            val rightPad = 14.dp.toPx()&#10;&#10;            val graphH = size.height - bottomPad - topPad&#10;            val graphW = size.width - leftPad - rightPad&#10;&#10;            fun xAt(t: Long): Float {&#10;                val f = (t - windowStart).toFloat() / durationMs.toFloat()&#10;                return leftPad + (f * graphW).coerceIn(0f, graphW)&#10;            }&#10;            fun yAt(bpm: Float): Float {&#10;                val f = (bpm - minBpm) / bpmRange&#10;                return topPad + graphH - (f * graphH).coerceIn(0f, graphH)&#10;            }&#10;&#10;            // Axes&#10;            drawLine(Color.Gray, Offset(leftPad, topPad + graphH), Offset(leftPad + graphW, topPad + graphH), 2f)&#10;            drawLine(Color.Gray, Offset(leftPad, topPad), Offset(leftPad, topPad + graphH), 2f)&#10;&#10;            // Build contiguous segments (split on big gaps)&#10;            val segments = mutableListOf&lt;MutableList&lt;Int&gt;&gt;()&#10;            var current = mutableListOf&lt;Int&gt;()&#10;            for (i in points.indices) {&#10;                if (i == 0) {&#10;                    current.add(i)&#10;                } else {&#10;                    val gap = points[i].timestamp - points[i - 1].timestamp&#10;                    if (gap &gt; maxGapMs) {&#10;                        segments.add(current)&#10;                        current = mutableListOf(i)&#10;                    } else {&#10;                        current.add(i)&#10;                    }&#10;                }&#10;            }&#10;            if (current.isNotEmpty()) segments.add(current)&#10;&#10;            // Draw fills and smoothed lines per segment (no point markers)&#10;            segments.forEach { seg -&gt;&#10;                if (seg.size &lt; 1) return@forEach&#10;&#10;                // Fill path (smoothed series)&#10;                val fillPath = Path()&#10;                val firstIdx = seg.first()&#10;                val firstX = xAt(points[firstIdx].timestamp)&#10;                val firstY = yAt(smoothed[firstIdx])&#10;                fillPath.moveTo(firstX, firstY)&#10;                for (idx in seg.drop(1)) {&#10;                    fillPath.lineTo(xAt(points[idx].timestamp), yAt(smoothed[idx]))&#10;                }&#10;                // close to baseline&#10;                val lastIdx = seg.last()&#10;                fillPath.lineTo(xAt(points[lastIdx].timestamp), topPad + graphH) // baseline at bottom&#10;                fillPath.lineTo(firstX, topPad + graphH)&#10;                fillPath.close()&#10;                drawPath(fillPath, color = Color.Red.copy(alpha = 0.12f))&#10;&#10;                // Line path (smoothed) - rounded caps for smooth appearance&#10;                val linePath = Path()&#10;                linePath.moveTo(firstX, firstY)&#10;                for (idx in seg.drop(1)) {&#10;                    linePath.lineTo(xAt(points[idx].timestamp), yAt(smoothed[idx]))&#10;                }&#10;                drawPath(&#10;                    linePath,&#10;                    color = Color.Red,&#10;                    style = Stroke(width = 3f, cap = androidx.compose.ui.graphics.StrokeCap.Round)&#10;                )&#10;            }&#10;&#10;            // Y ticks and labels&#10;            drawIntoCanvas { c -&gt;&#10;                val paint = android.graphics.Paint().apply {&#10;                    color = android.graphics.Color.BLACK&#10;                    textSize = 20f&#10;                    textAlign = android.graphics.Paint.Align.RIGHT&#10;                    isAntiAlias = true&#10;                }&#10;                val yTicks = 4&#10;                for (i in 0..yTicks) {&#10;                    val v = minBpm + (bpmRange * (i.toFloat() / yTicks.toFloat()))&#10;                    val y = yAt(v)&#10;                    drawLine(Color.Gray, Offset(leftPad - 6f, y), Offset(leftPad, y), 2f)&#10;                    c.nativeCanvas.drawText(v.toInt().toString(), leftPad - 10f, y + (paint.textSize * 0.35f), paint)&#10;                }&#10;                val labelPaint = android.graphics.Paint(paint).apply { textAlign = android.graphics.Paint.Align.CENTER }&#10;                c.nativeCanvas.drawText(&quot;BPM&quot;, leftPad - 30f, topPad - 18f, labelPaint)&#10;            }&#10;&#10;            // X ticks for last hour at 0,15,30,45,60 minutes&#10;            drawIntoCanvas { c -&gt;&#10;                val paint = android.graphics.Paint().apply {&#10;                    color = android.graphics.Color.BLACK&#10;                    textSize = 16f&#10;                    textAlign = android.graphics.Paint.Align.CENTER&#10;                    isAntiAlias = true&#10;                }&#10;                intArrayOf(60, 45, 30, 15, 0).forEach { labelMinutes -&gt;&#10;                    val offsetMin = (60 - labelMinutes).toLong()&#10;                    val t = windowStart + TimeUnit.MINUTES.toMillis(offsetMin)&#10;                    val x = xAt(t)&#10;                    drawLine(Color.Gray, Offset(x, topPad + graphH), Offset(x, topPad + graphH + 6f), 2f)&#10;                    val text = &quot;${labelMinutes}m&quot;&#10;                    c.nativeCanvas.drawText(text, x, topPad + graphH + 22f, paint)&#10;                }&#10;                val labelPaint = android.graphics.Paint(paint)&#10;                c.nativeCanvas.drawText(&quot;Minutes ago (last hour)&quot;, leftPad + graphW / 2f, topPad + graphH + 42f, labelPaint)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun EmergencyAlert(onCancel: () -&gt; Unit) {&#10;    // Fullscreen semi-transparent overlay with a centered card and a Cancel button&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(Color(0x88000000)),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Surface(&#10;            modifier = Modifier&#10;                .padding(20.dp)&#10;                .fillMaxWidth()&#10;                .wrapContentHeight(),&#10;            color = Color.White,&#10;            shape = androidx.compose.foundation.shape.RoundedCornerShape(8.dp),&#10;            shadowElevation = 8.dp&#10;        ) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .padding(12.dp),&#10;                horizontalAlignment = Alignment.CenterHorizontally,&#10;                verticalArrangement = Arrangement.spacedBy(8.dp)&#10;            ) {&#10;                Text(&quot;Emergency activated&quot;, style = MaterialTheme.typography.title2, color = Color(0xFFB00020))&#10;                Text(&quot;High heart rate detected. Tap Cancel to dismiss.&quot;, style = MaterialTheme.typography.body2, color = Color.Black)&#10;                Row(&#10;                    horizontalArrangement = Arrangement.Center,&#10;                    modifier = Modifier.fillMaxWidth()&#10;                ) {&#10;                    androidx.wear.compose.material.Button(&#10;                        onClick = onCancel,&#10;                        modifier = Modifier.size(width = 110.dp, height = 40.dp),&#10;                        colors = androidx.wear.compose.material.ButtonDefaults.primaryButtonColors(&#10;                            backgroundColor = Color.LightGray,&#10;                            contentColor = Color.Black&#10;                        )&#10;                    ) {&#10;                        Text(&quot;Cancel&quot;)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.fyp.safesyncwatch.presentation&#10;&#10;import android.Manifest&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.pm.PackageManager&#10;import android.hardware.Sensor&#10;import android.hardware.SensorEvent&#10;import android.hardware.SensorEventListener&#10;import android.hardware.SensorManager&#10;import android.os.Bundle&#10;import android.os.Handler&#10;import android.os.Looper&#10;import android.util.Log&#10;import android.widget.Toast&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.compose.animation.core.FastOutSlowInEasing&#10;import androidx.compose.animation.core.RepeatMode&#10;import androidx.compose.animation.core.animateFloat&#10;import androidx.compose.animation.core.infiniteRepeatable&#10;import androidx.compose.animation.core.rememberInfiniteTransition&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.DisposableEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateListOf&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.Path&#10;import androidx.compose.ui.graphics.drawscope.Stroke&#10;import androidx.compose.ui.graphics.drawscope.drawIntoCanvas&#10;import androidx.compose.ui.graphics.nativeCanvas&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.platform.LocalLifecycleOwner&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.viewinterop.AndroidView&#10;import androidx.core.content.ContextCompat&#10;import androidx.lifecycle.Lifecycle&#10;import androidx.lifecycle.LifecycleEventObserver&#10;import androidx.wear.compose.material.MaterialTheme&#10;import androidx.wear.compose.material.Text&#10;import com.fyp.safesyncwatch.theme.PulseHeartView&#10;import com.fyp.safesyncwatch.theme.SafeSyncWatchTheme&#10;import com.google.android.gms.wearable.PutDataMapRequest&#10;import com.google.android.gms.wearable.Wearable&#10;import java.util.concurrent.TimeUnit&#10;import java.time.*&#10;import androidx.compose.material3.Surface&#10;import android.content.BroadcastReceiver&#10;import android.content.IntentFilter&#10;import android.annotation.SuppressLint&#10;&#10;fun startOfTodayMillis(): Long {&#10;    val zone = ZoneId.systemDefault()&#10;    return LocalDate.now(zone).atStartOfDay(zone).toInstant().toEpochMilli()&#10;}&#10;&#10;data class HeartRateEntry(&#10;    val timestamp: Long,&#10;    val bpm: Int&#10;)&#10;class MainActivity : ComponentActivity(), SensorEventListener {&#10;    companion object {&#10;        const val ACTION_HR_UPDATED = &quot;com.fyp.safesyncwatch.HEART_RATE_UPDATED&quot;&#10;    }&#10;&#10;    private val hrUpdateReceiver = object : BroadcastReceiver() {&#10;        override fun onReceive(context: Context, intent: Intent) {&#10;            val bpm = intent.getIntExtra(&quot;bpm&quot;, -1)&#10;            val ts = intent.getLongExtra(&quot;timestamp&quot;, System.currentTimeMillis())&#10;            if (bpm &gt; 0) {&#10;                // Avoid duplicate entries with same timestamp&#10;                if (heartRateHistory.isEmpty() || heartRateHistory.last().timestamp != ts) {&#10;                    heartRateHistory.add(HeartRateEntry(ts, bpm))&#10;                    // keep UI state in sync&#10;                    heartRateBpm = bpm&#10;                    pruneOldHeartRateHistory(startOfTodayMillis())&#10;                    saveHeartRateHistory()&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private lateinit var sensorManager: SensorManager&#10;    private var heartRateSensor: Sensor? = null&#10;    private var heartRateBpm by mutableStateOf(0)&#10;    private var sensorPermissionGranted by mutableStateOf(false)&#10;    private val TAG = &quot;HeartRate&quot;&#10;    private val heartRateHistory = mutableStateListOf&lt;HeartRateEntry&gt;()&#10;    private val handler = Handler(Looper.getMainLooper())&#10;    private var showDetachedDialog by mutableStateOf(false)&#10;    private val bpmTimeoutMs = 30_000L // 30 seconds&#10;    private var lastValidBpmTime by mutableStateOf(0L) // Keep track of the last valid BPM time&#10;    private var emergencyActivated by mutableStateOf(false)&#10;    private var emergencyDismissedAt by mutableStateOf(0L) // avoid immediate re-trigger&#10;&#10;    private val requestBackgroundPermissionLauncher =&#10;        registerForActivityResult(ActivityResultContracts.RequestPermission()) { isGranted: Boolean -&gt;&#10;            if (isGranted) {&#10;                android.util.Log.d(TAG, &quot;BODY_SENSORS_BACKGROUND granted.&quot;)&#10;                startHrService()&#10;            } else {&#10;                android.util.Log.e(TAG, &quot;BODY_SENSORS_BACKGROUND denied.&quot;)&#10;                // still attempt to start the service on older devices; for API 34+ it's required to have bg permission&#10;                if (android.os.Build.VERSION.SDK_INT &lt; 34) startHrService()&#10;            }&#10;        }&#10;&#10;    private val requestPermissionLauncher =&#10;        registerForActivityResult(ActivityResultContracts.RequestPermission()) { isGranted: Boolean -&gt;&#10;            if (isGranted) {&#10;                Log.d(TAG, &quot;BODY_SENSORS permission GRANTED by user.&quot;)&#10;                sensorPermissionGranted = true&#10;                initializeAndRegisterSensor()&#10;&#10;                // Request background sensors permission explicitly on Android 34+&#10;                if (android.os.Build.VERSION.SDK_INT &gt;= 34) {&#10;                    // launch the background permission flow&#10;                    requestBackgroundPermissionLauncher.launch(Manifest.permission.BODY_SENSORS_BACKGROUND)&#10;                } else {&#10;                    startHrService()&#10;                }&#10;            } else {&#10;                Log.e(TAG, &quot;BODY_SENSORS permission DENIED by user.&quot;)&#10;                sensorPermissionGranted = false&#10;                heartRateBpm = -1&#10;            }&#10;        }&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        Log.d(TAG, &quot;onCreate called&quot;)&#10;        sensorManager = getSystemService(Context.SENSOR_SERVICE) as SensorManager&#10;        loadHeartRateHistory()&#10;        setContent {&#10;            SafeSyncWatchTheme {&#10;                if (!sensorPermissionGranted) { RequestHeartRatePermission() }&#10;&#10;                WearRoot(&#10;                    heartRateList = heartRateHistory.toList(),&#10;                    latestBpm = heartRateBpm,&#10;                    permissionGranted = sensorPermissionGranted,&#10;                    emergencyRequested = emergencyActivated,&#10;                    onEmergencyHandled = {&#10;                        // Send emergency to phone so phone app can proceed, then clear activation&#10;                        try {&#10;                            sendEmergencyToPhone(heartRateBpm)&#10;                        } catch (e: Exception) {&#10;                            Log.e(TAG, &quot;sendEmergencyToPhone failed&quot;, e)&#10;                        }&#10;&#10;                        emergencyActivated = false&#10;                        emergencyDismissedAt = System.currentTimeMillis()&#10;                    },&#10;                    onRequestBatteryExemption = { requestIgnoreBatteryOptimizations() }&#10;                )&#10;&#10;                SensorLifecycleEffect()&#10;            }&#10;        }&#10;    }&#10;&#10;    @Composable&#10;    private fun RequestHeartRatePermission() {&#10;        DisposableEffect(Unit) {&#10;            when (ContextCompat.checkSelfPermission(this@MainActivity, Manifest.permission.BODY_SENSORS)) {&#10;                PackageManager.PERMISSION_GRANTED -&gt; {&#10;                    Log.d(TAG, &quot;BODY_SENSORS permission already granted (checked in Composable).&quot;)&#10;                    sensorPermissionGranted = true&#10;                    if (android.os.Build.VERSION.SDK_INT &gt;= 34) {&#10;                        startHrService()&#10;                    } else {&#10;                        startHrService()&#10;                    }&#10;                }&#10;                else -&gt; {&#10;                    Log.d(TAG, &quot;Requesting BODY_SENSORS permission from Composable.&quot;)&#10;                    requestPermissionLauncher.launch(Manifest.permission.BODY_SENSORS)&#10;                }&#10;            }&#10;            onDispose { }&#10;        }&#10;    }&#10;&#10;    private fun initializeAndRegisterSensor() {&#10;        if (!sensorPermissionGranted) {&#10;            Log.w(TAG, &quot;initializeAndRegisterSensor: Permission not granted. Aborting.&quot;)&#10;            heartRateBpm = -1 // Indicates permission issue&#10;            return&#10;        }&#10;        if (heartRateSensor == null) {&#10;            heartRateSensor = sensorManager.getDefaultSensor(Sensor.TYPE_HEART_RATE)&#10;        }&#10;        if (heartRateSensor == null) {&#10;            Log.e(TAG, &quot;Heart rate sensor NOT AVAILABLE on this device.&quot;)&#10;            heartRateBpm = -2 // Indicates sensor N/A&#10;        } else {&#10;            Log.d(TAG, &quot;Heart rate sensor found: ${heartRateSensor?.name}. Registering listener.&quot;)&#10;            val registered = sensorManager.registerListener(this, heartRateSensor, SensorManager.SENSOR_DELAY_NORMAL)&#10;            if (registered) {&#10;                Log.d(TAG, &quot;Heart rate listener registered successfully.&quot;)&#10;                // Start the timeout check immediately after registering&#10;                handler.removeCallbacks(bpmTimeoutRunnable)&#10;                handler.postDelayed(bpmTimeoutRunnable, bpmTimeoutMs)&#10;                lastValidBpmTime = System.currentTimeMillis() // Initialize time&#10;            } else {&#10;                Log.e(TAG, &quot;Failed to register heart rate listener.&quot;)&#10;                heartRateBpm = -2 // Treat as sensor N/A if registration fails&#10;            }&#10;        }&#10;    }&#10;&#10;    private val bpmTimeoutRunnable = Runnable {&#10;        // Only trigger if no new BPM has come in since the timeout was scheduled&#10;        if (System.currentTimeMillis() - lastValidBpmTime &gt;= bpmTimeoutMs) {&#10;            heartRateBpm = 0&#10;            Toast.makeText(&#10;                this,&#10;                &quot;No heart rate detected. Please ensure the watch is properly worn.&quot;,&#10;                Toast.LENGTH_LONG&#10;            ).show()&#10;            Log.d(TAG, &quot;BPM Timeout! Setting BPM to 0 and showing Toast.&quot;)&#10;        }&#10;    }&#10;&#10;    private fun unregisterSensorListener() {&#10;        Log.d(TAG, &quot;Unregistering heart rate listener.&quot;)&#10;        sensorManager.unregisterListener(this)&#10;    }&#10;&#10;    @Composable&#10;    private fun SensorLifecycleEffect() {&#10;        val lifecycleOwner = LocalLifecycleOwner.current&#10;        DisposableEffect(lifecycleOwner, sensorPermissionGranted) {&#10;            val observer = LifecycleEventObserver { _, event -&gt;&#10;                when (event) {&#10;                    Lifecycle.Event.ON_RESUME -&gt; {&#10;                        Log.d(TAG, &quot;SensorLifecycleEffect: ON_RESUME&quot;)&#10;                        if (sensorPermissionGranted) {&#10;                        }&#10;                    }&#10;                    Lifecycle.Event.ON_PAUSE -&gt; {&#10;                        Log.d(TAG, &quot;SensorLifecycleEffect: ON_PAUSE&quot;)&#10;                    }&#10;                    else -&gt; { /* Do nothing */ }&#10;                }&#10;            }&#10;            lifecycleOwner.lifecycle.addObserver(observer)&#10;            onDispose {&#10;                Log.d(TAG, &quot;SensorLifecycleEffect onDispose&quot;)&#10;                lifecycleOwner.lifecycle.removeObserver(observer)&#10;            }&#10;        }&#10;    }&#10;    override fun onSensorChanged(event: SensorEvent?) {&#10;        if (event?.sensor?.type == Sensor.TYPE_HEART_RATE) {&#10;            val bpm = event.values[0].toInt()&#10;            val currentTime = System.currentTimeMillis()&#10;            if (bpm &gt; 0) {&#10;                heartRateBpm = bpm&#10;                if (bpm &gt; 140 &amp;&amp; !emergencyActivated &amp;&amp; currentTime - emergencyDismissedAt &gt; TimeUnit.SECONDS.toMillis(30)) {&#10;                    emergencyActivated = true&#10;                }&#10;                if (heartRateHistory.isEmpty() || heartRateHistory.last().bpm != bpm) {&#10;                    heartRateHistory.add(HeartRateEntry(currentTime, bpm))&#10;                    pruneOldHeartRateHistory(System.currentTimeMillis() - TimeUnit.HOURS.toMillis(48))&#10;                    saveHeartRateHistory()&#10;                }&#10;                sendHeartRateToPhone(bpm)&#10;                lastValidBpmTime = currentTime&#10;                handler.removeCallbacks(bpmTimeoutRunnable)&#10;                handler.postDelayed(bpmTimeoutRunnable, bpmTimeoutMs)&#10;            } else if (bpm == 0 &amp;&amp; heartRateBpm &gt; 0) {&#10;                handler.removeCallbacks(bpmTimeoutRunnable)&#10;                handler.postDelayed(bpmTimeoutRunnable, bpmTimeoutMs)&#10;            }&#10;        }&#10;    }&#10;&#10;    @SuppressLint(&quot;UnspecifiedRegisterReceiverFlag&quot;)&#10;    override fun onResume() {&#10;        super.onResume()&#10;        pruneOldHeartRateHistory(startOfTodayMillis())&#10;        if (sensorPermissionGranted) initializeAndRegisterSensor()&#10;        // Register receiver to update graph in real-time&#10;        val filter = IntentFilter(ACTION_HR_UPDATED)&#10;        if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.TIRAMISU) {&#10;            // mark as not exported for unprotected local broadcasts&#10;            registerReceiver(hrUpdateReceiver, filter, Context.RECEIVER_NOT_EXPORTED)&#10;        } else {&#10;            // older devices: lint suppressed above because we intentionally use the older overload&#10;            registerReceiver(hrUpdateReceiver, filter)&#10;        }&#10;&#10;        // Load history saved by the background service while activity was paused / screen-off&#10;        try {&#10;            loadHeartRateHistory()&#10;            // Ensure we only show today's data on resume&#10;            pruneOldHeartRateHistory(startOfTodayMillis())&#10;            if (heartRateHistory.isNotEmpty()) {&#10;                heartRateBpm = heartRateHistory.last().bpm&#10;            }&#10;            Log.d(TAG, &quot;onResume: Loaded ${heartRateHistory.size} history entries from prefs&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;onResume: failed to load heart rate history&quot;, e)&#10;        }&#10;    }&#10;&#10;    override fun onPause() {&#10;        super.onPause()&#10;        Log.d(TAG, &quot;Lifecycle.Event.ON_PAUSE from Activity&quot;)&#10;        unregisterSensorListener()&#10;        handler.removeCallbacks(bpmTimeoutRunnable)&#10;        // Unregister receiver&#10;        try { unregisterReceiver(hrUpdateReceiver) } catch (_: Exception) { }&#10;    }&#10;&#10;    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {&#10;        val accuracyStatus = when (accuracy) {&#10;            SensorManager.SENSOR_STATUS_ACCURACY_HIGH -&gt; &quot;HIGH&quot;&#10;            SensorManager.SENSOR_STATUS_ACCURACY_MEDIUM -&gt; &quot;MEDIUM&quot;&#10;            SensorManager.SENSOR_STATUS_ACCURACY_LOW -&gt; &quot;LOW&quot;&#10;            SensorManager.SENSOR_STATUS_UNRELIABLE -&gt; &quot;UNRELIABLE&quot;&#10;            else -&gt; &quot;UNKNOWN ($accuracy)&quot;&#10;        }&#10;        Log.d(TAG, &quot;onAccuracyChanged: ${sensor?.name}, accuracy: $accuracyStatus&quot;)&#10;    }&#10;&#10;    private fun sendHeartRateToPhone(bpm: Int) {&#10;        Log.e(&quot;WEAR_SEND_DEBUG&quot;, &quot;!!!! Attempting to SEND BPM ($bpm) to phone. Timestamp: ${System.currentTimeMillis()} !!!!&quot;)&#10;        if (!isFinishing &amp;&amp; !isDestroyed) {&#10;            try {&#10;                val dataClient = Wearable.getDataClient(this)&#10;                val request = PutDataMapRequest.create(&quot;/heartRate&quot;).apply {&#10;                    dataMap.putInt(&quot;bpm&quot;, bpm)&#10;                    dataMap.putLong(&quot;timestamp&quot;, System.currentTimeMillis())&#10;                }.asPutDataRequest().setUrgent()&#10;&#10;                dataClient.putDataItem(request)&#10;                    .addOnSuccessListener { Log.d(&quot;WEAR_SEND_DEBUG&quot;, &quot;SUCCESS: Heart rate data ($bpm BPM) sent.&quot;) }&#10;                    .addOnFailureListener { e -&gt; Log.e(&quot;WEAR_SEND_DEBUG&quot;, &quot;FAILURE: Failed to send heart rate data.&quot;, e) }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;WEAR_SEND_DEBUG&quot;, &quot;EXCEPTION while sending heart rate data&quot;, e)&#10;            }&#10;        } else {&#10;            Log.w(&quot;WEAR_SEND_DEBUG&quot;, &quot;Activity is finishing/destroyed. CANNOT SEND BPM: $bpm&quot;)&#10;        }&#10;    }&#10;&#10;    // Send an emergency notification/payload to phone via DataClient + MessageClient&#10;    private fun sendEmergencyToPhone(bpm: Int) {&#10;        val timestamp = System.currentTimeMillis()&#10;        val safeBpm = if (bpm &gt; 0) bpm else -1&#10;        Log.d(TAG, &quot;Preparing to send EMERGENCY to phone. bpm=$safeBpm ts=$timestamp&quot;)&#10;&#10;        // 1) Put a DataItem so phone can observe even if message delivery fails&#10;        try {&#10;            val dataClient = Wearable.getDataClient(this)&#10;            val putRequest = PutDataMapRequest.create(&quot;/emergency&quot;).apply {&#10;                dataMap.putLong(&quot;timestamp&quot;, timestamp)&#10;                dataMap.putInt(&quot;bpm&quot;, safeBpm)&#10;                dataMap.putString(&quot;source&quot;, &quot;watch&quot;)&#10;            }.asPutDataRequest().setUrgent()&#10;&#10;            dataClient.putDataItem(putRequest)&#10;                .addOnSuccessListener { Log.d(TAG, &quot;Emergency DataItem sent&quot;) }&#10;                .addOnFailureListener { e -&gt; Log.e(TAG, &quot;Emergency DataItem failed&quot;, e) }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Exception while putting emergency DataItem&quot;, e)&#10;        }&#10;&#10;        // 2) Send a low-latency Message to connected nodes so phone can act immediately&#10;        try {&#10;            val payload = &quot;{\&quot;type\&quot;:\&quot;emergency\&quot;,\&quot;timestamp\&quot;:$timestamp,\&quot;bpm\&quot;:$safeBpm}&quot;.toByteArray()&#10;            Wearable.getNodeClient(this).connectedNodes&#10;                .addOnSuccessListener { nodes -&gt;&#10;                    if (nodes.isEmpty()) {&#10;                        Log.w(TAG, &quot;No connected nodes to send emergency message to&quot;)&#10;                    }&#10;                    for (node in nodes) {&#10;                        Wearable.getMessageClient(this).sendMessage(node.id, &quot;/emergency&quot;, payload)&#10;                            .addOnSuccessListener { Log.d(TAG, &quot;Emergency message sent to ${node.displayName}&quot;) }&#10;                            .addOnFailureListener { e -&gt; Log.e(TAG, &quot;Failed sending emergency message to ${node.displayName}&quot;, e) }&#10;                    }&#10;                }&#10;                .addOnFailureListener { e -&gt; Log.e(TAG, &quot;Failed getting connected nodes for emergency&quot;, e) }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Exception while sending emergency message&quot;, e)&#10;        }&#10;    }&#10;&#10;    private fun saveHeartRateHistory() {&#10;        val prefs = getSharedPreferences(&quot;heart_rate_prefs&quot;, Context.MODE_PRIVATE)&#10;        val historyString = heartRateHistory.joinToString(&quot;;&quot;) { &quot;${it.timestamp},${it.bpm}&quot; }&#10;        prefs.edit().putString(&quot;history_v2&quot;, historyString).apply() // Use a new key for the new format&#10;        Log.d(TAG, &quot;Saved history: $historyString&quot;)&#10;    }&#10;&#10;    private fun loadHeartRateHistory() {&#10;        val prefs = getSharedPreferences(&quot;heart_rate_prefs&quot;, Context.MODE_PRIVATE)&#10;        val historyString = prefs.getString(&quot;history_v2&quot;, &quot;&quot;) ?: &quot;&quot;&#10;        heartRateHistory.clear()&#10;        if (historyString.isNotEmpty()) {&#10;            try {&#10;                val entries = historyString.split(&quot;;&quot;).mapNotNull { raw -&gt;&#10;                    val parts = raw.trim().split(&quot;,&quot;)&#10;                    if (parts.size != 2) return@mapNotNull null&#10;                    val ts = parts[0].trim().toLongOrNull() ?: return@mapNotNull null&#10;                    val bpm = parts[1].trim().toIntOrNull() ?: return@mapNotNull null&#10;                    HeartRateEntry(ts, bpm)&#10;                }&#10;                heartRateHistory.addAll(entries)&#10;                // Prune old data on load as well (keep last 48 hours as elsewhere)&#10;                pruneOldHeartRateHistory(System.currentTimeMillis() - TimeUnit.HOURS.toMillis(48))&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error loading heart rate history&quot;, e)&#10;            }&#10;        }&#10;        Log.d(TAG, &quot;Loaded history items: ${heartRateHistory.size}&quot;)&#10;    }&#10;&#10;    //remove data older than a certain point&#10;    private fun pruneOldHeartRateHistory(thresholdTimestamp: Long) {&#10;        val removed = heartRateHistory.removeAll { it.timestamp &lt; thresholdTimestamp }&#10;        if (removed) Log.d(TAG, &quot;Pruned old heart rate entries. Kept: ${heartRateHistory.size}&quot;)&#10;    }&#10;&#10;    private fun startHrService() {&#10;        val i = Intent(this, com.fyp.safesyncwatch.service.HeartRateService::class.java)&#10;        if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.O) {&#10;            startForegroundService(i)&#10;        } else {&#10;            startService(i)&#10;        }&#10;    }&#10;&#10;    private fun stopHrService() {&#10;        val i = Intent(this, com.fyp.safesyncwatch.service.HeartRateService::class.java)&#10;        stopService(i)&#10;    }&#10;&#10;}&#10;data class BinnedPoint(&#10;    val tStart: Long,&#10;    val tCenter: Long,&#10;    val min: Int,&#10;    val median: Int,&#10;    val max: Int,&#10;    val count: Int&#10;)&#10;&#10;fun binHeartRate(&#10;    data: List&lt;HeartRateEntry&gt;,&#10;    windowStartMs: Long,&#10;    windowEndMs: Long,&#10;    binSizeMs: Long&#10;): List&lt;BinnedPoint&gt; {&#10;    if (windowEndMs &lt;= windowStartMs) return emptyList()&#10;&#10;    //Snap bin grid to the window start so x axis line up&#10;    val bStart = windowStartMs&#10;&#10;    val buckets = mutableMapOf&lt;Long, MutableList&lt;Int&gt;&gt;()&#10;    data.forEach { e -&gt;&#10;        if (e.timestamp in windowStartMs..windowEndMs) {&#10;            //Bin key measured from windowStartMs (no modulo shift)&#10;            val offset = e.timestamp - bStart&#10;            val key = bStart + (offset / binSizeMs) * binSizeMs&#10;            buckets.getOrPut(key) { mutableListOf() }.add(e.bpm)&#10;        }&#10;    }&#10;&#10;    val out = mutableListOf&lt;BinnedPoint&gt;()&#10;    var cursor = bStart&#10;    while (cursor &lt; windowEndMs) {&#10;        val list = buckets[cursor]&#10;        if (!list.isNullOrEmpty()) {&#10;            val sorted = list.sorted()&#10;            val sz = sorted.size&#10;            val med = if (sz % 2 == 1) sorted[sz / 2] else ((sorted[sz / 2 - 1] + sorted[sz / 2]) / 2)&#10;            out.add(&#10;                BinnedPoint(&#10;                    tStart = cursor,&#10;                    tCenter = cursor + binSizeMs / 2,&#10;                    min = sorted.first(),&#10;                    median = med,&#10;                    max = sorted.last(),&#10;                    count = sz&#10;                )&#10;            )&#10;        }&#10;        cursor += binSizeMs&#10;    }&#10;    return out&#10;}&#10;&#10;fun ema(values: List&lt;Float&gt;, alpha: Float = 0.3f): List&lt;Float&gt; {&#10;    if (values.isEmpty()) return values&#10;    val out = MutableList(values.size) { 0f }&#10;    out[0] = values[0]&#10;    for (i in 1 until values.size) {&#10;        out[i] = alpha * values[i] + (1 - alpha) * out[i - 1]&#10;    }&#10;    return out&#10;}&#10;&#10;@Composable&#10;fun HeartbeatScreen(bpm: Int, permissionGranted: Boolean) {&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(Color.White),&#10;        verticalArrangement = Arrangement.Center,&#10;        horizontalAlignment = Alignment.CenterHorizontally&#10;    ) {&#10;        Spacer(Modifier.height(15.dp))&#10;&#10;        PulseHeartViewCompose()&#10;&#10;        Spacer(Modifier.height(16.dp))&#10;&#10;        val displayText = when {&#10;            !permissionGranted &amp;&amp; bpm == -1 -&gt; &quot;Permission Denied&quot;&#10;            bpm == -2 -&gt; &quot;Sensor N/A&quot;&#10;            bpm == 0 &amp;&amp; permissionGranted -&gt; &quot;... BpM&quot;&#10;            bpm == 0 &amp;&amp; !permissionGranted -&gt; &quot;Requesting Permission...&quot;&#10;            bpm &gt; 0 &amp;&amp; permissionGranted -&gt; &quot;$bpm BpM&quot;&#10;            else -&gt; &quot;-- BpM&quot;&#10;        }&#10;&#10;        Text(&#10;            text = displayText,&#10;            style = MaterialTheme.typography.title1,&#10;            color = when {&#10;                bpm &gt; 140 &amp;&amp; permissionGranted -&gt; Color(0xFFB00020)&#10;                bpm &gt; 0 &amp;&amp; permissionGranted -&gt; Color.Black&#10;                else -&gt; Color.LightGray&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun HeartRateChartScreen(heartRateList: List&lt;HeartRateEntry&gt;) {&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(Color.White)&#10;            .verticalScroll(rememberScrollState()),&#10;        horizontalAlignment = Alignment.CenterHorizontally&#10;    ) {&#10;        HeartRateTimeChart(heartRateList)&#10;    }&#10;}&#10;&#10;@Composable&#10;fun PulseHeartViewCompose() {&#10;    AndroidView(&#10;        factory = { context -&gt; PulseHeartView(context) },&#10;        modifier = Modifier.size(72.dp)&#10;    )&#10;}&#10;&#10;@Composable&#10;fun HeartRateTimeChart(heartRateData: List&lt;HeartRateEntry&gt;) {&#10;    val chartHeightDp = 180.dp&#10;    val chartWidthDp = LocalConfiguration.current.screenWidthDp.dp - 32.dp&#10;&#10;    val now = System.currentTimeMillis()&#10;    val windowEnd = now&#10;    val windowStart = now - TimeUnit.HOURS.toMillis(1) // last hour&#10;    val durationMs = (windowEnd - windowStart).coerceAtLeast(1L)&#10;&#10;    val points = remember(heartRateData, now) {&#10;        heartRateData&#10;            .filter { it.timestamp in windowStart..windowEnd }&#10;            .sortedBy { it.timestamp }&#10;    }&#10;&#10;    if (points.isEmpty()) {&#10;        Box(&#10;            modifier = Modifier&#10;                .height(chartHeightDp)&#10;                .width(chartWidthDp)&#10;                .padding(8.dp)&#10;                .background(Color.DarkGray.copy(alpha = 0.1f)),&#10;            contentAlignment = Alignment.Center&#10;        ) { Text(&quot;No data in last hour&quot;, color = Color.LightGray) }&#10;        return&#10;    }&#10;&#10;    val bpmSeries = remember(points) { points.map { it.bpm.toFloat() } }&#10;    val smoothed = remember(bpmSeries) { ema(bpmSeries, alpha = 0.25f) }&#10;&#10;    // Determine visual bounds with some breathing room&#10;    val maxBpm = maxOf((points.maxOf { it.bpm }), 40)&#10;    val minBpm = minOf((points.minOf { it.bpm }), maxBpm - 20).coerceAtLeast(30)&#10;    val bpmRange = (maxBpm - minBpm).coerceAtLeast(1).toFloat()&#10;&#10;    val maxGapMs = TimeUnit.MINUTES.toMillis(2) // split the line if gap &gt; 2 minutes&#10;&#10;    Box(&#10;        modifier = Modifier&#10;            .height(chartHeightDp)&#10;            .width(chartWidthDp)&#10;            .padding(vertical = 8.dp)&#10;    ) {&#10;        Canvas(modifier = Modifier.matchParentSize()) {&#10;            val bottomPad = 36.dp.toPx()&#10;            val leftPad = 35.dp.toPx()&#10;            val topPad = 50.dp.toPx()&#10;            val rightPad = 14.dp.toPx()&#10;&#10;            val graphH = size.height - bottomPad - topPad&#10;            val graphW = size.width - leftPad - rightPad&#10;&#10;            fun xAt(t: Long): Float {&#10;                val f = (t - windowStart).toFloat() / durationMs.toFloat()&#10;                return leftPad + (f * graphW).coerceIn(0f, graphW)&#10;            }&#10;            fun yAt(bpm: Float): Float {&#10;                val f = (bpm - minBpm) / bpmRange&#10;                return topPad + graphH - (f * graphH).coerceIn(0f, graphH)&#10;            }&#10;&#10;            // Axes&#10;            drawLine(Color.Gray, Offset(leftPad, topPad + graphH), Offset(leftPad + graphW, topPad + graphH), 2f)&#10;            drawLine(Color.Gray, Offset(leftPad, topPad), Offset(leftPad, topPad + graphH), 2f)&#10;&#10;            // Build contiguous segments (split on big gaps)&#10;            val segments = mutableListOf&lt;MutableList&lt;Int&gt;&gt;()&#10;            var current = mutableListOf&lt;Int&gt;()&#10;            for (i in points.indices) {&#10;                if (i == 0) {&#10;                    current.add(i)&#10;                } else {&#10;                    val gap = points[i].timestamp - points[i - 1].timestamp&#10;                    if (gap &gt; maxGapMs) {&#10;                        segments.add(current)&#10;                        current = mutableListOf(i)&#10;                    } else {&#10;                        current.add(i)&#10;                    }&#10;                }&#10;            }&#10;            if (current.isNotEmpty()) segments.add(current)&#10;&#10;            // Draw fills and smoothed lines per segment (no point markers)&#10;            segments.forEach { seg -&gt;&#10;                if (seg.size &lt; 1) return@forEach&#10;&#10;                // Fill path (smoothed series)&#10;                val fillPath = Path()&#10;                val firstIdx = seg.first()&#10;                val firstX = xAt(points[firstIdx].timestamp)&#10;                val firstY = yAt(smoothed[firstIdx])&#10;                fillPath.moveTo(firstX, firstY)&#10;                for (idx in seg.drop(1)) {&#10;                    fillPath.lineTo(xAt(points[idx].timestamp), yAt(smoothed[idx]))&#10;                }&#10;                // close to baseline&#10;                val lastIdx = seg.last()&#10;                fillPath.lineTo(xAt(points[lastIdx].timestamp), topPad + graphH) // baseline at bottom&#10;                fillPath.lineTo(firstX, topPad + graphH)&#10;                fillPath.close()&#10;                drawPath(fillPath, color = Color.Red.copy(alpha = 0.12f))&#10;&#10;                // Line path (smoothed) - rounded caps for smooth appearance&#10;                val linePath = Path()&#10;                linePath.moveTo(firstX, firstY)&#10;                for (idx in seg.drop(1)) {&#10;                    linePath.lineTo(xAt(points[idx].timestamp), yAt(smoothed[idx]))&#10;                }&#10;                drawPath(&#10;                    linePath,&#10;                    color = Color.Red,&#10;                    style = Stroke(width = 3f, cap = androidx.compose.ui.graphics.StrokeCap.Round)&#10;                )&#10;            }&#10;&#10;            // Y ticks and labels&#10;            drawIntoCanvas { c -&gt;&#10;                val paint = android.graphics.Paint().apply {&#10;                    color = android.graphics.Color.BLACK&#10;                    textSize = 20f&#10;                    textAlign = android.graphics.Paint.Align.RIGHT&#10;                    isAntiAlias = true&#10;                }&#10;                val yTicks = 4&#10;                for (i in 0..yTicks) {&#10;                    val v = minBpm + (bpmRange * (i.toFloat() / yTicks.toFloat()))&#10;                    val y = yAt(v)&#10;                    drawLine(Color.Gray, Offset(leftPad - 6f, y), Offset(leftPad, y), 2f)&#10;                    c.nativeCanvas.drawText(v.toInt().toString(), leftPad - 10f, y + (paint.textSize * 0.35f), paint)&#10;                }&#10;                val labelPaint = android.graphics.Paint(paint).apply { textAlign = android.graphics.Paint.Align.CENTER }&#10;                c.nativeCanvas.drawText(&quot;BPM&quot;, leftPad - 30f, topPad - 18f, labelPaint)&#10;            }&#10;&#10;            // X ticks for last hour at 0,15,30,45,60 minutes&#10;            drawIntoCanvas { c -&gt;&#10;                val paint = android.graphics.Paint().apply {&#10;                    color = android.graphics.Color.BLACK&#10;                    textSize = 16f&#10;                    textAlign = android.graphics.Paint.Align.CENTER&#10;                    isAntiAlias = true&#10;                }&#10;                intArrayOf(60, 45, 30, 15, 0).forEach { labelMinutes -&gt;&#10;                    val offsetMin = (60 - labelMinutes).toLong()&#10;                    val t = windowStart + TimeUnit.MINUTES.toMillis(offsetMin)&#10;                    val x = xAt(t)&#10;                    drawLine(Color.Gray, Offset(x, topPad + graphH), Offset(x, topPad + graphH + 6f), 2f)&#10;                    val text = &quot;${labelMinutes}m&quot;&#10;                    c.nativeCanvas.drawText(text, x, topPad + graphH + 22f, paint)&#10;                }&#10;                val labelPaint = android.graphics.Paint(paint)&#10;                c.nativeCanvas.drawText(&quot;Minutes ago (last hour)&quot;, leftPad + graphW / 2f, topPad + graphH + 42f, labelPaint)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun EmergencyAlert(onCancel: () -&gt; Unit) {&#10;    // Fullscreen semi-transparent overlay with a centered card and a Cancel button&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(Color(0x88000000)),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Surface(&#10;            modifier = Modifier&#10;                .padding(20.dp)&#10;                .fillMaxWidth()&#10;                .wrapContentHeight(),&#10;            color = Color.White,&#10;            shape = androidx.compose.foundation.shape.RoundedCornerShape(8.dp),&#10;            shadowElevation = 8.dp&#10;        ) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .padding(12.dp),&#10;                horizontalAlignment = Alignment.CenterHorizontally,&#10;                verticalArrangement = Arrangement.spacedBy(8.dp)&#10;            ) {&#10;                Text(&quot;Emergency activated&quot;, style = MaterialTheme.typography.title2, color = Color(0xFFB00020))&#10;                Text(&quot;High heart rate detected. Tap Cancel to dismiss.&quot;, style = MaterialTheme.typography.body2, color = Color.Black)&#10;                Row(&#10;                    horizontalArrangement = Arrangement.Center,&#10;                    modifier = Modifier.fillMaxWidth()&#10;                ) {&#10;                    androidx.wear.compose.material.Button(&#10;                        onClick = onCancel,&#10;                        modifier = Modifier.size(width = 110.dp, height = 40.dp),&#10;                        colors = androidx.wear.compose.material.ButtonDefaults.primaryButtonColors(&#10;                            backgroundColor = Color.LightGray,&#10;                            contentColor = Color.Black&#10;                        )&#10;                    ) {&#10;                        Text(&quot;Cancel&quot;)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>